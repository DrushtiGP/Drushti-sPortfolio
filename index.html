<!-- File: index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>My Portfolio</title>
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@700&family=Open+Sans:wght@400;600&display=swap" rel="stylesheet" />
  <!-- External Stylesheet -->
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <!-- Navbar -->
  <header>
    <nav>
      <div class="logo"><a href="#hero">MyPortfolio</a></div>
      <div class="menu">
        <a href="#hero">Home</a>
        <a href="#about">About</a>
        <a href="#skills">Skills</a>
        <a href="#domain">Domain</a>
        <a href="#cases">Buisiness Cases</a>
        <a href="#contact">Contact</a>
      </div>
    </nav>
  </header>

  <!-- Hero Section -->
  <section id="hero" class="content-section">
    <h1>Hi, I'm Drushti</h1>
    <p class="tagline">Computer Science Undergrad | Tech Enthusiast | Problem Solver</p>
    <a href="#contact" class="btn">Get In Touch</a>
  </section>

  <!-- About Me Section -->
<section id="about" class="content-section">
    <h2 class="section-title">About Me</h2>
    <p>Hi, I'm Drushti!  
      I'm a Computer Science Engineering student with a deep interest in solving real-world problems through technology. I love breaking down complex challenges, thinking through different solutions, and building systems that actually work. For me, engineering isn't just about code‚Äîit's about understanding the problem, asking the right questions, and using logic, creativity, and tech to figure things out.
    </p>
    
    <p>
      I actively work on sharpening my problem-solving skills through data structures and algorithms, and I enjoy exploring core CS subjects like operating systems, DBMS, and computer networks to understand how things really function at the system level.
    </p>
    
    <p>
      I‚Äôve also worked on projects involving web development, where I use tools like HTML, CSS, JavaScript, and SQL databases to build functional and user-friendly applications. My real passion lies in learning how different technologies connect and how we can use them to build smart and scalable solutions.
    </p>
    
    <p>
      Outside of tech, I enjoy spending time in nature, reading books, and staying curious about how things work. I‚Äôm always open to learning from others, sharing ideas, and collaborating on interesting projects.
    </p>
    
    <p>Feel free to connect!</p>
  </section>
  

  <!-- Skills Section -->
  <section id="skills" class="content-section">
    <h2 class="section-title">Skills</h2>
  
    <div class="skills-category">
      <h3>Programming Languages</h3>
      <ul class="skills-list">
        <li>C++</li>
        <li>Python</li>
        <li>JavaScript</li>
      </ul>
    </div>
  
    <div class="skills-category">
      <h3>Web Development</h3>
      <ul class="skills-list">
        <li>HTML</li>
        <li>CSS</li>
        <li>JavaScript</li>
      </ul>
    </div>
  
    <div class="skills-category">
      <h3>Databases</h3>
      <ul class="skills-list">
        <li>MySQL</li>
        <li>SQLite</li>
      </ul>
    </div>
  
    <div class="skills-category">
      <h3>Core CS Subjects</h3>
      <ul class="skills-list">
        <li>Data Structures & Algorithms</li>
        <li>Operating Systems</li>
        <li>Computer Networks</li>
        <li>DBMS</li>
      </ul>
    </div>
  </section>
  
  <!-- Domain of Interest Section -->
  <section id="domain" class="content-section">
    <h2 class="section-title">Domain of Interest</h2>
    <p>I am passionate about leveraging technology to solve real-world problems and aspire to contribute to innovative solutions in the tech industry. My goal is to work as a software developer or system designer in leading product-based companies known for their cutting-edge technologies and impactful products.</p>
    <p>
        I am particularly interested in roles that involve system design and architecture, where I can apply my knowledge of data structures, algorithms, and core computer science principles to build scalable and efficient systems.
    </p>

    <p>
        I am committed to continuous learning and growth, aiming to collaborate with teams that value innovation, performance, and user-centric design.‚Äã


    </p>
</section>

<section id="cases" class="content-section">
  <h2 class="section-title">Business Cases</h2>

  <!-- Business Case 1 Start -->
  <div class="business-case">
    <h3 class="case-title">Business Case 1: Spam and Ham Email Detection Using Bloom Filters</h3>

    <div class="case-subsection">
      <h4> Problem Statement : </h4>
      <p>In an increasingly connected world, email spam continues to pose risks ‚Äî from phishing to unwanted content delivery. Conventional filters rely heavily on machine learning, but can we do more with less? What if we design a resource-light, explainable, and high-speed system using pure algorithms?
        This case study explores a classical, algorithmic approach to detect spam (junk) and ham (valid) emails using:
        <li>Bloom Filters (probabilistic data structure)</li>
      </p>
        
    </div>


    <div class="case-subsection">
      <h4>Real-world scenario: </h4>
      <p>Consider a lightweight email client on a budget phone or embedded device where you can‚Äôt afford ML inference. 
        Or, think of enterprises that require privacy (no model training on user data). This is where algorithmic spam detection shines.</p>
    </div>

    <div class="image-wrapper">
        <img src="Spam_vs_Ham.jpg" alt="Spam v/s Ham Classifier" class="case-image">
        <p class="image-caption">Figure 1: Spam vs Ham Email Classification Visualization</p>
        <p class="image-courtesy">Image courtesy: <a href="https://medium.datadriveninvestor.com/using-natural-language-processing-for-spam-detection-in-emails-281a7c22ddbc" target="_blank">Medium</a></p>
    </div>

    <div class="case-subsection">
      <h4>Let's dig more into bloom filter:</h4>
      <ul>
        <div class="card">
          <h3>Bloom Filter in Spam Detection</h3>
          <p>Bloom filters serve as lightweight, high-speed pre-filters to detect spam emails efficiently. They provide a probabilistic method to test membership of known spam indicators such as:</p>
          <ul class="styled-list">
            <li>Suspicious email addresses or domains</li>
            <li>Common spam keywords and phrases (e.g., ‚Äúlottery‚Äù, ‚Äúclick now‚Äù)</li>
            <li>Blacklisted or malicious URLs</li>
          </ul>
        </div>
        
        <section class="bloom-filter-section">
  <h3>üîç What is a Bloom Filter?</h3>
  <p>
    A <strong>Bloom filter</strong> is a space-effiecient data structure that tells whether an element may be in a set or definitely is not. If we look up an item in the Bloom filter , we can get two possible results.
    <ul>
      <li>The item is not present in the set : True negetaive</li>
      <li>The item might be present in the set : Can be either a False positive or True positive.</li>
    </ul>
  </p>
  <p>
    This structure is highly space-efficient and enables ultra-fast lookups, making it ideal for 
    applications like spam detection where slight false positives are acceptable, but false negatives are not.
  </p>

  <h3>Working of bloom filter:</h3>
  <p>Bloom filters use a clever combination of a bit array and multiple hash functions to efficiently check 
    whether an element is possibly in a set or definitely not in it.</p>
  <p><strong>To insert an item:</strong></p>
    <ul class="steps-list">
      <li>Hash the item with <em>k</em> functions.</li>
      <li>Set bits at resulting indices to 1.</li>
    </ul>

<div class="image-wrapper">
  <img src="insertion_Bloom.png" alt="Insertion in bloom filter" class="case-image" />
  <p class="image-caption">Figure 2: Insertion in Bloom filter</p>
  <p class="image-courtesy">
    Image courtesy: 
    <a href="https://www.enjoyalgorithms.com/blog/bloom-filter" target="_blank" rel="noopener noreferrer">
      enjoyalgorithms
    </a>
  </p>
</div>


<p><strong>To check membership:</strong></p>
    <ul class="steps-list">
      <li>Rehash the item.</li>
      <li>If all corresponding bits are  1: <em>Item may exist</em>.</li>
      <li>If any bit is 0: <em> definitely does not exist.</em></li>
    </ul>

<div class="image-wrapper">
  <img src="check_bloom.png" alt="Check membership" class="case-image" />
  <p class="image-caption">Figure 3: Check membership</p>
  <p class="image-courtesy">
    Image courtesy: 
    <a href="https://www.enjoyalgorithms.com/blog/bloom-filter" target="_blank" rel="noopener noreferrer">
      enjoyalgorithms
    </a>
  </p>
</div>

  
<p><strong>Example:</strong></p>

<div class="image-wrapper">
  <img src="Bloom_example.png" alt="example" class="case-image" />
  <p class="image-caption">Figure 4: Bloom Filter Visualization With Example:</p>
  <p class="image-courtesy">
    Image courtesy: 
    <a href="https://www.enjoyalgorithms.com/blog/bloom-filter" target="_blank" rel="noopener noreferrer">
      enjoyalgorithms
    </a>
  </p>
</div>

<section class="optimization-section">
  <h3>Optimization Strategies</h3>

  <ol>
    <li>
      <strong>Optimal number of hash functions (<code>k</code>)</strong>:
      <ul>
        <li>
          Formula: <code>k = (m/n) * ln(2)</code><br>
          where:
          <ul>
            <li><code>m</code> = bit array size</li>
            <li><code>n</code> = expected number of elements</li>
          </ul>
        </li>
      </ul>
    </li>

    <li>
      <strong>Increase bit array size (<code>m</code>)</strong>:
      <ul>
        <li>Reduces collisions and false positives.</li>
      </ul>
    </li>

    <li>
      <strong>Layered Filters</strong>:
      <ul>
        <li>Use <strong>multiple Bloom filters</strong> to cross-check and reduce false positives.</li>
      </ul>
    </li>
  </ol>
</section>


  <h3> Why Bloom Filters for Spam Detection?</h3>
  <ul>
    <li>Quickly pre-filters emails matching known spam patterns</li>
    <li>Reduces load on deeper machine learning models</li>
    <li>Consumes minimal memory for large datasets</li>
    <li>Ideal for high-throughput mail servers and scalable environments</li>
  </ul>
</section>


    </div>

    <!--<div class="case-subsection">
      <h4>üíª Code and Implementation</h4>
      <pre><code class="language-python">
        # Sample placeholder for Bloom filter implementation
        class BloomFilter:
        def __init__(self, size, hash_count):
            self.size = size
            self.hash_count = hash_count
            self.bit_array = [0] * size

        def add(self, item):
            # Add hash logic here
            pass

        def check(self, item):
            # Membership check
            pass
      </code></pre>
    </div>-->

    <div class="case-subsection">
  <h4>üìä Analysis and Efficiency</h4>
  <ul>
    <li>
      <strong>Time Complexity:</strong> 
      Insertion and query operations take <code>O(k)</code> time, where <code>k</code> is the number of hash functions used. This is constant-time in practice and highly efficient.
    </li>
    <li>
      <strong>Space Complexity:</strong> 
      Requires <code>m</code> bits of memory, where <code>m</code> is the size of the bit array. This is very space-efficient compared to storing actual items, especially when <code>m</code> and <code>k</code> are optimally chosen based on expected inputs.
    </li>
    <li>
      <strong>False Positive Rate:</strong> 
      Given by the formula:  
      <br><code>P = (1 - e<sup>-kn/m</sup>)<sup>k</sup></code>  
      where:
      <ul>
        <li><code>n</code> = number of inserted elements</li>
        <li><code>m</code> = size of bit array</li>
        <li><code>k</code> = number of hash functions</li>
      </ul>
      This rate increases with more insertions and can be reduced by optimizing <code>k</code> and <code>m</code>.
    </li>
  </ul>
</div>

<div class="case-subsection">
  <h4 class="section-heading">‚öñÔ∏è Trade-offs in Bloom Filter</h4>
  <ul class="tradeoffs-list">
    <li><strong>Space vs Accuracy:</strong> Using a larger bit array reduces false positives but increases memory usage.</li>
    <li><strong>Speed vs Complexity:</strong> More hash functions improve accuracy but increase insertion/query time.</li>
    <li><strong>False Positives:</strong> Bloom filters may say an item is present even if it‚Äôs not, but they never miss actual items.</li>
    <li><strong>Scalability:</strong> Once created, the size of the Bloom filter cannot be changed without rebuilding it.</li>
  </ul>
</div>



   <div class="case-subsection">
  <h4> Reflection and Learnings</h4>
  <p>This project provided a clear understanding of how Bloom Filters efficiently manage membership queries with limited memory usage. Exploring the balance between false positive rates and space savings helped me appreciate the practical trade-offs involved in probabilistic data structures.</p>
  <p>While the theory behind multiple hash functions initially seemed complex, implementing the insertion and query processes clarified their role in reducing collisions and errors. Visualizing the process through code and diagrams further reinforced these concepts.</p>
  <p>Overall, this experience enhanced my grasp of space-efficient data structures and inspired me to explore advanced variants, such as Counting Bloom Filters, in future work.</p>
</div>

 <div class="case-subsection">
  <h4>üìö References</h4>
  <ul>
    <li><a href="https://medium.com/@sylvain.tiset/bloom-filters-101-the-power-of-probabilistic-data-structures-ef1b4a422b0b" target="_blank" rel="noopener noreferrer">Bloom Filters 101: The Power of Probabilistic Data Structures ‚Äì Medium</a></li>
    <li><a href="https://www.enjoyalgorithms.com/blog/bloom-filter" target="_blank" rel="noopener noreferrer">Bloom Filter Explanation ‚Äì Enjoy Algorithms</a></li>
    <li><a href="https://youtu.be/GT0En1dGntY?si=sBJatePRNHM1jGfs" target="_blank" rel="noopener noreferrer">Bloom Filter Explained ‚Äì YouTube</a></li>
  </ul>
</div>


<!-- Business Case 2 Start -->
<div class="business-case">
  <h3 class="case-title">Business Case 2:  Amazon's Product Recommendation Engine</h3>

  <div class="case-subsection">
    <h4> Problem Statement : </h4>
    <p>Amazon generates a significant portion of its revenue through its recommendation engine ‚Äî reportedly up to 35% of total sales. The system personalizes shopping experiences, boosts customer retention, and increases Average Order Value (AOV).</p>
    <p>Traditional user-based collaborative filtering faced scalability issues due to the vast number of users and products. To address this, Amazon developed an item-to-item collaborative filtering algorithm that focuses on the relationships between items rather than users.</p>
    <p>This makes it an excellent example of how algorithms drive business success.</p>
  </div>

  <div class="case-subsection">
    <h4> Initial Recommendation Approaches : </h4>
    <p>Amazon first explored traditional User-User Collaborative Filtering:
      <ul>
        <li>Match users with similar purchase histories</li>
        <li>Recommend items bought by those similar users</li>
      </ul>
    </p>
    
    <p>Problem with this approach:
      <ul>
        <li>It doesn‚Äôt scale well with millions of users.</li>
        <li>New users often have no history ‚Äî cold start problem.</li>
        <li>User preferences evolve rapidly.</li>
        <li>Users are not always the best comparison units ‚Äî but items are more stable.</li>
      </ul>
    </p>
  </div>

  <p>Thus amazon built a item-item based collaborative filtering which asks 
    <b>What items are similar to the one you're looking at ? </b> rather than asking 
    <b>which users are like you?</b>
  </p>

  <div class="image-wrapper">
    <img src="Item-item based CF.png" alt="IBCF example" class="case-image">
    <p class="image-caption">Figure 3: IBCF example</p>
    <p class="image-courtesy">Image courtesy: <a href="https://jerichosiahaya.medium.com/item-based-collaborative-filtering-explained-eaf3e31f39c1" target="_blank">Medium</a></p>
  </div>
  <p>There are 4 fruit items that will be tested in a recommendation system, namely orange, strawberry, apple, and banana. 
  The parameter used here is the buyer who has successfully purchased any of these four items.</p>
  
  <p>The first buyer purchases oranges, apples, and bananas. The second buyer purchases oranges
    and apples, while the third buyer only purchases apples. Let‚Äôs say the third buyer wants to get a recommendation for other fruits based on the fruit they have purchased, namely apples. Then, the recommendation system will calculate 
    the similarity of other fruits based on the purchase history of the buyer who has purchased apples.</p>
  
    <p>
      It can be seen that the second buyer bought apples and also oranges, while the first buyer bought oranges, apples, and bananas. The analysis result that can be obtained from this recommendation system is that apples are purchased by the first and second buyers who also both purchase oranges. 
      Therefore, the recommendation system will recommend oranges to the third buyer.


    </p>
    <div class="case-subsection">
    <h4>Data Structures & Algorithms Powering Item-to-Item Collaborative Filtering:</h4>
    <p>  
    Amazon‚Äôs personalized recommendation engine, used across millions of users and items, is a high-performance algorithmic system. The brilliance lies in how it uses classical data structures with real-world constraints to scale efficiently. 
    </p>
    <ul>
<div class="card">
  <h3>1. Co-occurrence Matrix using Nested Hash Maps</h3>
  <p>
    In many recommendation systems and market basket analysis applications, it is essential to track how often two items are purchased together. 
    This co-occurrence information helps identify meaningful patterns between items 
    (e.g., customers who bought <i>bread</i> also bought <i>butter</i>). 
    The challenge lies in handling sparse and large-scale data ‚Äî 
    not every pair of items will be co-purchased, so storing all possible item-item combinations would be highly inefficient.
  </p>

  <section class="decision-tree-section">
    <h3>Data structure used:</h3>
    <p>
      To store pairwise item purchase relationships, we use a nested hash map:
    </p>
    <p style="text-align: center;">
      <b>unordered_map&lt;int, unordered_map&lt;int, int&gt;&gt;</b>
    </p>

    <b>Because:</b>
    <ul>
      <li><b>Sparse Matrix Friendly:</b> Most item pairs are never co-purchased; the nested hash map avoids storing unnecessary zeroes.</li>
      <li><b>Memory Efficient:</b> Stores only meaningful relationships, drastically reducing space in comparison to a full matrix.</li>
      <li><b>Fast Insertions & Updates:</b> Average-case time complexity of <code>O(1)</code> per insert/update due to the use of hash maps.</li>
      <li><b>Symmetric Update:</b> Co-occurrence is naturally bidirectional (itemA co-occurs with itemB ‚Üí itemB co-occurs with itemA).</li>
    </ul>

    <h3>Time & Space Complexity:</h3>

    <p><b>Time Complexity:</b></p>
    <ul>
      <li><code>O(1)</code> per insert/update (amortized) ‚Äî thanks to hash map access.</li>
      <li><code>O(n¬≤)</code> if computing all pairwise combinations, but we only process actual purchases ‚Üí practically much lower.</li>
    </ul>

    <p><b>Space Complexity:</b></p>
    <ul>
      <li><code>O(n ¬∑ k)</code> where <code>n</code> is the number of items and <code>k</code> is the average number of co-occurring neighbors per item.</li>
    </ul>

    <p >
      üîó <a href="https://github.com/DrushtiGP/Drushti-sPortfolio/blob/main/cooccurrence_matrix.cpp" 
      target="_blank" rel="noopener noreferrer">View Code</a>
    </p>

    <p>
      This approach is ideal for handling real-world data where relationships between elements are sparse, dynamic, and scale-dependent.
      By combining datastructure performance with hash-based flexibility, we achieve both efficiency and scalability ‚Äî 
      crucial for high-throughput applications.
    </p>
  </section>
</div>

  <div class="card">
  <h3>2. Cosine Similarity Computation</h3>
  <p>
    After gathering item co-occurrence data, we must determine how similar two items are ‚Äî even if they were never bought together directly. Cosine similarity offers a robust way to measure this,
    by comparing the direction of sparse co-purchase vectors instead of their magnitude.
  </p>

  <section class="decision-tree-section">
    <h3>Data structure used:</h3>
    <p>
      Each item is modeled as a personality vector using:
      <br>
      <p style="text-align: center;">
        <b>unordered_map&lt;int, int&gt;</b>
      </p>
    </p>
    <b>Because:</b>
    <ul>
      <li>Sparse Representation: Only co-purchased items are stored, reducing space significantly.</li>
      <li>Popularity Bias Mitigation: Cosine similarity normalizes for item frequency, helping prevent dominant items (like AirPods) from biasing results.</li>
      <li>Interpretable: Intuitively reflects how similar two items are based on shared neighbors.</li>
    </ul>

    <h3>Time & Space Complexity:</h3>

    <p><b>Time Complexity:</b></p>
    <ul>
      <li><code>O(min(|A|, |B|))</code> ‚Äî Efficient because we only traverse keys present in both vectors.</li>
    </ul>

    <p><b>Space Complexity:</b></p>
    <ul>
      <li><code>O(k)</code> ‚Äî where <code>k</code> is the number of co-purchased items per item vector.</li>
    </ul>


    <p>
      This technique balances performance and precision, enabling discovery of related items based on contextual rather than absolute behavior. Ideal for personalized recommendations.
    </p>
  </section>
</div>

<div class="card">
  <h3>3. Maintaining Top-K Similar Items</h3>
  <p>
    Computing all item-to-item similarities creates large outputs. Instead of storing everything, we only retain the top-K most similar items for each product using a min-heap.
    This ensures we're only keeping what truly matters to the user.
  </p>

  <section class="decision-tree-section">
    <h3>Data structure used:</h3>
    <p>
      A dynamic min-heap for each item using:
      <br>
      <p style="text-align: center;">
        <b>priority_queue&lt;pair&lt;float, int&gt;, vector&lt;&gt;, greater&lt;&gt;&gt;</b>
      </p>
    </p>
    <b>Because:</b>
    <ul>
      <li>Efficient Pruning: The least similar item is quickly discarded when a better match arrives.</li>
      <li>Memory Controlled: Limits memory to only <code>K</code> entries per item.</li>
      <li>Dynamic Adaptability: Suitable for streaming scenarios or periodic updates.</li>
    </ul>

    <h3>Time & Space Complexity:</h3>

    <p><b>Time Complexity:</b></p>
    <ul>
      <li><code>O(log K)</code> per insert ‚Äî maintains sorted top-K list efficiently.</li>
    </ul>

    <p><b>Space Complexity:</b></p>
    <ul>
      <li><code>O(K)</code> per item ‚Äî bounded by number of neighbors retained.</li>
    </ul>

    <p style="text-align: right;">
      üîó <a href="https://github.com/DrushtiGP/Drushti-sPortfolio/blob/main/min_heap.cpp" target="_blank" rel="noopener noreferrer">View Code</a>
    </p>

    <p>
      This structure ensures that recommendations are both relevant and performant. Especially useful for user-facing applications where speed is critical.
    </p>
  </section>
</div>

<div class="card">
  <h3>4. Final Recommendation Lookup</h3>
  <p>
    After offline computation of similarities and top-K filtering, the actual recommendation phase is a simple lookup. The user expects fast results,
    and so we pre-index everything using a hash map.
  </p>

  <section class="decision-tree-section">
    <h3>Data structure used:</h3>
    <p>
      A hash map of precomputed top-K items:
      <br>
      <p style="text-align: center;">
        <b>unordered_map&lt;int, vector&lt;pair&lt;int, float&gt;&gt;&gt;</b>
      </p>
    </p>
    <b>Because:</b>
    <ul>
      <li>Instant Retrieval: Allows direct lookup of similar items in <code>O(1)</code> time.</li>
      <li>Precomputed Logic: Reduces recommendation latency to sub-millisecond range.</li>
      <li>Scalable: Can handle millions of item queries per second with proper caching.</li>
    </ul>

    <h3>Time & Space Complexity:</h3>

    <p><b>Time Complexity:</b></p>
    <ul>
      <li><code>O(1)</code> ‚Äî simple hash table access per item ID.</li>
    </ul>

    <p><b>Space Complexity:</b></p>
    <ul>
      <li><code>O(n √ó K)</code> ‚Äî where <code>n</code> is the total number of items, and <code>K</code> is the number of top similar items stored.</li>
    </ul>

    <p>
      This design turns heavy batch computation into real-time action, enabling billions of recommendations per day with minimal delay. A core technique in modern recommender systems.
    </p>
  </section>
</div>


  <section class="optimization-section">
    <h3>Optimization Strategies</h3>
    <ol>
      <li>
        <strong>Pruning:</strong>
        <ul>
          <li>Pruning removes branches that provide little predictive power, which helps to prevent overfitting.</li>
        </ul>
      </li>

      <li>
        <strong>Hyperparameter Tuning:</strong>
        <ul>
          <li>Tuning parameters such as tree depth and minimum samples per leaf can improve accuracy and prevent overfitting.</li>
        </ul>
      </li>

      <li>
        <strong>Ensemble Methods:</strong>
        <ul>
          <li>Use of ensemble methods like Random Forests or Gradient Boosting Trees can improve decision tree performance.</li>
        </ul>
      </li>
    </ol>
  </section>

  <h3> Why Decision Trees for Fraud Detection?</h3>
  <ul>
    <li>Decision trees are simple, interpretable models ideal for fraud detection.</li>
    <li>They can handle both categorical and numerical data effectively.</li>
    <li>Provide transparent decision-making, which is essential for regulatory compliance.</li>
    <li>Effective in detecting patterns in large datasets and handling missing values well.</li>
  </ul>

  <div class="case-subsection">
    <h4>üìä Analysis and Efficiency</h4>
    <ul>
      <li>
        <strong>Time Complexity:</strong> Decision trees have a time complexity of O(n log n) for training, where n is the number of data points. Query time is O(log n) for classification.
      </li>
      <li>
        <strong>Space Complexity:</strong> Space complexity depends on the size of the tree, with a worst-case space complexity of O(n) if the tree is unpruned.
      </li>
      <li>
        <strong>Interpretability:</strong> Decision trees are easy to visualize and understand, which helps in explaining the reasons behind fraud detection decisions.
      </li>
    </ul>
  </div>

  <div class="case-subsection">
    <h4 class="section-heading">‚öñÔ∏è Trade-offs in Decision Trees</h4>
    <ul class="tradeoffs-list">
      <li><strong>Overfitting:</strong> Decision trees can easily overfit if the tree is too deep, which reduces generalizability.</li>
      <li><strong>Bias-Variance Trade-off:</strong> Shallow trees are biased and underfit, while deep trees have high variance and can overfit.</li>
      <li><strong>Computation Cost:</strong> Large datasets may result in deep trees with long training times.</li>
      <li><strong>Scalability:</strong> For very large datasets, decision trees might not be the best choice compared to other algorithms like Random Forests or XGBoost.</li>
    </ul>
  </div>

  <div class="case-subsection">
    <h4> Reflection and Learnings</h4>
    <p>This project provided valuable insight into how decision trees can be used for fraud detection, which is a practical, interpretable, and highly efficient approach for such applications. Understanding how decision trees balance the trade-offs between complexity and performance allowed me to better optimize the model.</p>
    <p>The ability to visualize decision trees and trace their decisions made me appreciate the importance of interpretability in real-time fraud detection systems. This case study has sparked an interest in exploring ensemble methods like Random Forests for even better results in fraud detection.</p>
  </div>

  <div class="case-subsection">
    <h4>üìö References</h4>
    <ul>
      <li><a href="https://www.analyticsvidhya.com/blog/2019/09/understanding-decision-tree-algorithm/" target="_blank" rel="noopener noreferrer">Understanding Decision Trees ‚Äì Analytics Vidhya</a></li>
      <li><a href="https://scikit-learn.org/stable/modules/tree.html" target="_blank" rel="noopener noreferrer">Decision Trees in Scikit-learn</a></li>
      <li><a href="https://www.youtube.com/watch?v=7VeUPuFGJHk" target="_blank" rel="noopener noreferrer">Decision Trees Explained ‚Äì YouTube</a></li>
    </ul>
  </div>
</div>

<!-- Business Case 2 End -->


<!-- Contact Section -->
<section id="contact" class="content-section">
    <h2 class="section-title">Get in Touch</h2>
    <p>If you have any questions or just want to connect, feel free to reach out through the form below or via my social links!</p>
  
    <div class="contact-form-container">
      <form action="https://formspree.io/f/xyzeqojq" method="POST" class="contact-form">
        <input type="text" name="name" placeholder="Your Name" required />
        <input type="email" name="email" placeholder="Your Email" required />
        <textarea name="message" rows="5" placeholder="Your Message" required></textarea>
        <button type="submit" class="send-button">Send</button>
      </form>
    </div>
  
    <div class="social-links">
      <a href="https://github.com/DrushtiGP" target="_blank">GitHub |</a>
      <a href="https://www.linkedin.com/in/drushti-pawar" target="_blank">LinkedIn</a>
    </div>
  </section>
  
</body>
</html>
